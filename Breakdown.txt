The application was profiled with VTune in hotspot mode, revealing that four threads dominated CPU utilisation. The first 15 of the 26 seconds of runtime were consumed by two threads related to compiler processes. Following this, the `App.main()` thread begins, indicating the start of the application's execution, so filtered in to focus only on that thread. The significant time spent loading and parsing the data from CSV was also filtered out, leaving around 2 seconds of actual data processing.

Data Smoothing consumed 170 ms (23% overall) of CPU time. The performance cost here is attributed to operations `splitOn` from analytic::AnalyticQueryEngine::partition → table::StandardTableSliceGroup::create → table::StandardTableSliceGroup::splitOn, and iterative actions performed by java::lang::iterable::forEach which are necessary for organising data into partitions to apply smoothing calculations, accounting for 10.8% of CPU time each. 

Aggregation (Summarization) took 156 ms (21.5% overall) of CPU time. The `splitOn` function again played a crucial role, taking 17.0% of the time, indicative of the intensive computation required for splitting and aggregating data. It uses hashmaps and a bitmap-backed selection to reduce the computational load.

Filtering operations, aimed at removing rows based on specific criteria, accounted for 100 ms (13.5% overall) of CPU time. This stage involves evaluating conditions for each row and constructing a new table with selected rows, The need to copy rows to a new table (`copyRowsToTable` accounting for 8.4%), and the preparation of a new table structure to hold filtered results (`emptyCopy`) are primary reasons for the computational load in this phase.

Joining was the least time-consuming at 40 ms (5.4% overall). Despite the complexity of joining operations, the time taken was relatively low, possibly due to reduced dataset sizes after prior filtering and aggregation operations. This operation involves matching rows based on key columns, with `joining::DataFrameJoiner::inner` and `joining::DataFrameJoiner::crossProduct` to merge tables.
